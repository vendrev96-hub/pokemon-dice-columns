<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PokÃ©Push â€” Final (Column Selector)</title>
  <style>
    :root{
      --ink:#0b1220; --muted:#475569; --panel: rgba(255,255,255,.92);
      --p1:#f59e0b; --p2:#ef4444;
      --grid:#94a3b8; --label:#1f2937; --shadow: 0 12px 40px rgba(2,6,23,.14);
      --chip-bg:#e0f2fe; --chip-fg:#075985;
      --sel:#0ea5e9; --sel-bg:#e0f2fe; --sel-border:#7dd3fc;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:
        radial-gradient(1100px 700px at 15% 10%, rgba(14,165,233,.16), transparent 60%),
        radial-gradient(1100px 700px at 85% 90%, rgba(139,92,246,.16), transparent 60%),
        linear-gradient(135deg,#eef2ff,#f8fafc);
    }
    .wrap{max-width:1024px;margin:28px auto;padding:16px}
    .card{background:var(--panel);backdrop-filter: blur(8px);border-radius:22px;box-shadow:var(--shadow);padding:18px}
    h1{margin:0 0 10px;font-size:22px;color:var(--ink)}
    .ctrlbar{display:flex;align-items:center;gap:14px;margin:6px 0 10px 0;flex-wrap:wrap}
    .side{display:flex;align-items:center;gap:10px}
    .badge{padding:6px 12px;border-radius:999px;font-weight:700;font-size:12px;color:#0b1220;background:#f1f5f9;box-shadow:0 2px 6px rgba(0,0,0,.06)}
    .spacer{flex:1}
    .btn{border:0;border-radius:14px;padding:12px 16px;color:#fff;cursor:pointer;font-weight:700;box-shadow:0 10px 24px rgba(0,0,0,.16);transition:transform .06s ease}
    .btn:active{transform:translateY(1px)}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .btn-move{background:linear-gradient(180deg,#10b981,#059669)}
    .btn-reset{background:#e2e8f0;color:#0f172a}
    .small{font-size:12px;color:var(--muted);margin-left:8px}
    .selector{display:flex;gap:8px;align-items:center;margin:8px 0 6px 0;flex-wrap:wrap}
    .selbtn{min-width:36px;height:36px;border-radius:10px;border:1px solid #cbd5e1;background:#fff;color:#0b1220;font-weight:700;display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 6px 14px rgba(2,6,23,.08);}
    .selbtn.active{background:var(--sel-bg); border-color:var(--sel-border); color:#075985; box-shadow:0 8px 18px rgba(14,165,233,.18);}
    .selmeta{font-size:12px;color:#475569}
    canvas.board{display:block;border-radius:18px;box-shadow:0 16px 40px rgba(2,6,23,.15);background:#fff}
    canvas.die{border-radius:12px;box-shadow:0 8px 20px rgba(0,0,0,.12);cursor:pointer;background:#fff}
    canvas.die.disabled{cursor:default;opacity:.9}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>PokÃ©Push â€” Final (Column Selector)</h1>
      <div class="ctrlbar">
        <div class="side">
          <span class="badge">P1 âš¡</span>
          <canvas id="dieP1" class="die" width="60" height="60" title="Roll (P1)"></canvas>
        </div>
        <div class="side">
          <span class="badge">P2 ðŸ”¥</span>
          <canvas id="dieP2" class="die" width="60" height="60" title="Roll (P2)"></canvas>
        </div>
        <div class="spacer"></div>
        <button id="move" class="btn btn-move" disabled>Move</button>
        <button id="reset" class="btn btn-reset">Reset</button>
        <span id="meta" class="small">P1 to roll</span>
      </div>

      <div class="selector" id="selector">
        <span class="selmeta">Select columns (sum must equal die):</span>
        <button class="selbtn" data-col="1">1</button>
        <button class="selbtn" data-col="2">2</button>
        <button class="selbtn" data-col="3">3</button>
        <button class="selbtn" data-col="4">4</button>
        <button class="selbtn" data-col="5">5</button>
        <button class="selbtn" data-col="6">6</button>
        <span class="selmeta" id="selSum">Sum: 0</span>
      </div>

      <canvas id="game" class="board" width="672" height="528"></canvas>
    </div>
  </div>

<script>
// ---- Constants ----
const ROWS=5, COLS=6, CELL=96, PAD=24;
const W = COLS*CELL + PAD*2;
const H = ROWS*CELL + PAD*2;

// ---- State ----
let p1 = Array(COLS).fill(1);
let p2 = Array(COLS).fill(3);
let turn = 0;           // 0=P1 (down), 1=P2 (up)
let die = [null,null];  // per-player
let winner = null;
let plan = [];          // distinct columns (1..6)
let animQueue = [];
let animating = false;

// ---- DOM ----
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const meta = document.getElementById('meta');
const btnMove = document.getElementById('move');
const btnReset = document.getElementById('reset');
const dieP1 = document.getElementById('dieP1');
const dieP2 = document.getElementById('dieP2');
const d1 = dieP1.getContext('2d');
const d2 = dieP2.getContext('2d');
const selector = document.getElementById('selector');
const selSumEl = document.getElementById('selSum');

// ---- Utils ----
function easeInOut(t){ return t<.5 ? 2*t*t : -1+(4-2*t)*t; }
function setMeta(text){ meta.textContent = text ?? (winner!=null ? (`Winner: P${winner+1}`) : (die[turn]==null ? `P${turn+1} to roll` : `P${turn+1} die: ${die[turn]}`)); }
function planSum(){ return plan.reduce((a,b)=>a+b,0); }
function canMove(){ return die[turn]!=null && plan.length>0 && planSum()===die[turn] && !animating && winner==null; }
function updateControls(){
  btnMove.disabled = !canMove();
  refreshDice(); setMeta(); draw(); refreshSelector();
}
function refreshSelector(){
  selSumEl.textContent = 'Sum: ' + planSum();
  const btns = selector.querySelectorAll('.selbtn');
  btns.forEach(b=>{
    const col = +b.dataset.col;
    b.classList.toggle('active', plan.includes(col));
    b.disabled = (die[turn]==null) || ( !plan.includes(col) && (planSum()+col > (die[turn]??0)) ) || animating || winner!=null;
  });
}

// ---- Sprites (procedural) ----
function roundRect(ctx,x,y,w,h,r,fill,stroke){ if (w<2*r) r=w/2; if (h<2*r) r=h/2; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); if (fill) ctx.fill(); if (stroke) ctx.stroke(); }
function drawP1Sprite(cx, cy){ ctx.save(); ctx.translate(cx,cy); const s=CELL-18; ctx.fillStyle='#fff'; ctx.shadowColor='rgba(0,0,0,.18)'; ctx.shadowBlur=10; ctx.shadowOffsetY=2; roundRect(ctx,-s/2,-s/2,s,s,16,true,false); ctx.shadowBlur=0; ctx.fillStyle='#f59e0b'; ctx.fillRect(-s/2,-s/2,s,6); ctx.fillStyle='#f59e0b'; drawBolt(0,0,s*0.34); ctx.restore(); }
function drawP2Sprite(cx, cy){ ctx.save(); ctx.translate(cx,cy); const s=CELL-18; ctx.fillStyle='#fff'; ctx.shadowColor='rgba(0,0,0,.18)'; ctx.shadowBlur=10; ctx.shadowOffsetY=2; roundRect(ctx,-s/2,-s/2,s,s,16,true,false); ctx.shadowBlur=0; ctx.fillStyle='#ef4444'; ctx.fillRect(-s/2,-s/2,s,6); ctx.fillStyle='#ef4444'; drawFlame(0,0,s*0.26); ctx.restore(); }
function drawBolt(x,y,r){ ctx.beginPath(); ctx.moveTo(x-r*0.3,y-r*0.8); ctx.lineTo(x+r*0.05,y-r*0.1); ctx.lineTo(x-r*0.2,y-r*0.1); ctx.lineTo(x+r*0.3,y+r*0.8); ctx.lineTo(x-r*0.05,y+r*0.1); ctx.lineTo(x+r*0.2,y+r*0.1); ctx.closePath(); ctx.fill(); }
function drawFlame(x,y,r){ ctx.beginPath(); ctx.moveTo(x,y+r*0.9); ctx.quadraticCurveTo(x-r*0.8,y+r*0.1,x,y-r); ctx.quadraticCurveTo(x+r*0.8,y+r*0.1,x,y+r*0.9); ctx.closePath(); ctx.fill(); }

// ---- Background particles ----
const sparks=[], flames=[];
function spawnElectric(){ const x=PAD+Math.random()*(W-PAD*2); const y0=PAD,y1=PAD+ROWS*CELL; const seg=6, pts=[{x, y:y0}]; for(let i=1;i<seg;i++){ const t=i/(seg-1); pts.push({x:x+(Math.random()*40-20), y:y0+t*(y1-y0)}); } pts.push({x:x+(Math.random()*40-20), y:y1}); sparks.push({pts,a:1}); }
function spawnSparkle(){ const x=PAD+Math.random()*(W-PAD*2); const y=PAD+Math.random()*(ROWS*CELL); sparks.push({spark:true,x,y,r:2+Math.random()*3,a:1}); }
function spawnFlame(){ const x=PAD+Math.random()*(W-PAD*2); const y=PAD+ROWS*CELL+12; const vx=(Math.random()*1.2-0.6); const vy=-(1.0+Math.random()*1.4); const r=6+Math.random()*10; flames.push({x,y,vx,vy,r,a:0.9}); }
let lastAnim=performance.now();
function drawBackground(dt){
  ctx.save(); ctx.beginPath(); ctx.rect(PAD,PAD,COLS*CELL,ROWS*CELL); ctx.clip();
  if (turn===0){
    const g=ctx.createLinearGradient(PAD,PAD,W-PAD,H-PAD); g.addColorStop(0,'#fff7ed'); g.addColorStop(1,'#fffbeb'); ctx.fillStyle=g; ctx.fillRect(PAD,PAD,COLS*CELL,ROWS*CELL);
    if (Math.random()<0.02) spawnElectric(); if (Math.random()<0.18) spawnSparkle();
    for(let i=sparks.length-1;i>=0;i--){ const s=sparks[i]; s.a-=dt*0.7; if (s.a<=0){ sparks.splice(i,1); continue; } ctx.globalAlpha=Math.max(0,s.a); if(s.spark){ ctx.fillStyle='#facc15'; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); } else { ctx.lineWidth=3; ctx.strokeStyle='#fde047'; ctx.beginPath(); ctx.moveTo(s.pts[0].x,s.pts[0].y); for(let j=1;j<s.pts.length;j++) ctx.lineTo(s.pts[j].x,s.pts[j].y); ctx.stroke(); } }
  } else {
    const g=ctx.createLinearGradient(PAD,PAD,PAD,PAD+ROWS*CELL); g.addColorStop(0,'#fff1f2'); g.addColorStop(1,'#fee2e2'); ctx.fillStyle=g; ctx.fillRect(PAD,PAD,COLS*CELL,ROWS*CELL);
    if (Math.random()<0.25) spawnFlame(); for(let i=flames.length-1;i>=0;i--){ const f=flames[i]; f.x+=f.vx; f.y+=f.vy; f.r*=0.986; f.a-=0.01; if (f.a<=0 || f.r<1.5){ flames.splice(i,1); continue; } ctx.globalAlpha=Math.max(0,f.a); const grd=ctx.createRadialGradient(f.x,f.y,1,f.x,f.y,f.r); grd.addColorStop(0,'#fb7185'); grd.addColorStop(1,'rgba(251,113,133,0)'); ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(f.x,f.y,f.r,0,Math.PI*2); ctx.fill(); }
  }
  ctx.restore(); ctx.globalAlpha=1;
}

// ---- Main draw ----
function draw(){
  const now=performance.now(); const dt=Math.min(0.05,(now-lastAnim)/1000); lastAnim=now;
  ctx.clearRect(0,0,canvas.width, canvas.height);
  drawBackground(dt);
  // grid + labels
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim();
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--label').trim();
  ctx.font = '600 18px Inter,system-ui,Segoe UI,Roboto';
  for (let r=0;r<=ROWS;r++){ ctx.beginPath(); ctx.moveTo(PAD, PAD+r*CELL); ctx.lineTo(PAD+COLS*CELL, PAD+r*CELL); ctx.stroke(); }
  for (let c=0;c<=COLS;c++){ ctx.beginPath(); ctx.moveTo(PAD+c*CELL, PAD); ctx.lineTo(PAD+c*CELL, PAD+ROWS*CELL); ctx.stroke(); }
  for (let c=0;c<COLS;c++){ const x=PAD+c*CELL; ctx.fillText(String(c+1), x+CELL/2-5, PAD-8); }

  // on-board selection: glow per selected column + top marker
  for (const v of plan){
    const col=v-1;
    const x=PAD+col*CELL, y=PAD;
    // soft glow
    ctx.save();
    const g=ctx.createLinearGradient(x,y,x+CELL,y+ROWS*CELL);
    g.addColorStop(0,'rgba(14,165,233,.18)'); g.addColorStop(1,'rgba(14,165,233,.08)');
    ctx.fillStyle=g; ctx.fillRect(x,y,CELL,ROWS*CELL);
    ctx.restore();
    // marker triangle
    ctx.fillStyle='#0ea5e9';
    ctx.beginPath();
    ctx.moveTo(x+CELL/2, y-16);
    ctx.lineTo(x+CELL/2-8, y-4);
    ctx.lineTo(x+CELL/2+8, y-4);
    ctx.closePath(); ctx.fill();
  }

  // pieces
  for (let c=0;c<COLS;c++){ const cx = PAD + c*CELL + CELL/2; if (p1[c]!=null){ const cy=PAD+p1[c]*CELL + CELL/2; drawP1Sprite(cx, cy); } if (p2[c]!=null){ const cy=PAD+p2[c]*CELL + CELL/2; drawP2Sprite(cx, cy); } }
}

// ---- Interaction (board + selector) ----
canvas.addEventListener('click', (e)=>{
  if (winner!=null || die[turn]==null || animating) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left - PAD, y = e.clientY - rect.top - PAD;
  if (x<0 || y<0) return;
  const col = Math.floor(x/CELL)+1; if (col<1 || col>COLS) return;
  toggleColumn(col);
});
selector.addEventListener('click', (e)=>{
  const btn = e.target.closest('.selbtn'); if (!btn) return;
  const col = +btn.dataset.col; toggleColumn(col);
});
function toggleColumn(col){
  const cur = die[turn]; if (cur==null || winner!=null || animating) return;
  const i = plan.indexOf(col);
  if (i>=0){ plan.splice(i,1); }
  else { if (planSum()+col>cur) return; plan.push(col); }
  updateControls();
}

// ---- Dice UI ----
function drawDie(ctx2, face, clickable, tint){
  const w = ctx2.canvas.width, h = ctx2.canvas.height;
  ctx2.clearRect(0,0,w,h);
  ctx2.save(); ctx2.shadowColor='rgba(0,0,0,.22)'; ctx2.shadowBlur=10; ctx2.shadowOffsetY=2; ctx2.fillStyle='#fff';
  roundRect(ctx2,3,3,w-6,h-6,12,true,false); ctx2.restore();
  ctx2.lineWidth=2; ctx2.strokeStyle = clickable ? tint : '#cbd5e1'; roundRect(ctx2,3,3,w-6,h-6,12,false,true);
  if (!face) return;
  const cx=w/2, cy=h/2, r=4.2, offs=15; ctx2.fillStyle='#0b1220';
  const left=3+offs, right=w-3-offs, top=3+offs, bottom=h-3-offs;
  const pip=(px,py)=>{ ctx2.beginPath(); ctx2.arc(px,py,r,0,Math.PI*2); ctx2.fill(); };
  switch(face){ case 1: pip(cx,cy); break;
    case 2: pip(left,top); pip(right,bottom); break;
    case 3: pip(left,top); pip(cx,cy); pip(right,bottom); break;
    case 4: pip(left,top); pip(right,top); pip(left,bottom); pip(right,bottom); break;
    case 5: pip(left,top); pip(right,top); pip(cx,cy); pip(left,bottom); pip(right,bottom); break;
    case 6: pip(left,top); pip(right,top); pip(left,cy); pip(right,cy); pip(left,bottom); break; }
}
function refreshDice(){
  dieP1.classList.toggle('disabled', !(turn===0 && die[0]==null && winner==null && !animating));
  dieP2.classList.toggle('disabled', !(turn===1 && die[1]==null && winner==null && !animating));
  drawDie(d1, turn===0? die[0] : null, (turn===0 && die[0]==null && winner==null && !animating), getComputedStyle(document.documentElement).getPropertyValue('--p1'));
  drawDie(d2, turn===1? die[1] : null, (turn===1 && die[1]==null && winner==null && !animating), getComputedStyle(document.documentElement).getPropertyValue('--p2'));
}
dieP1.addEventListener('click', ()=>{ if (turn!==0 || die[0]!=null || winner!=null || animating) return; roll(0); });
dieP2.addEventListener('click', ()=>{ if (turn!==1 || die[1]!=null || winner!=null || animating) return; roll(1); });
function roll(player){
  const val = Math.floor(Math.random()*6)+1;
  die[player] = val; updateControls();
  setTimeout(()=>{ if (!hasAnyValidPlan(val)){ die[player]=null; plan=[]; turn=1-turn; updateControls(); } }, 200);
}

// ---- Validation ----
function isPlanValid(order){
  let s1 = p1.slice(); let s2 = p2.slice();
  const mover = turn;
  const step = (colIdx)=>{
    const dir = (mover===0)? +1 : -1;
    const self = (mover===0)? s1 : s2; const opp = (mover===0)? s2 : s1;
    const cur = self[colIdx]; if (cur==null) return false;
    const tgt = cur + dir; if (tgt<0 || tgt>=ROWS) return false;
    if (opp[colIdx]===tgt){
      const oppT = tgt + dir; if (oppT<0 || oppT>=ROWS) return false;
      if (opp[colIdx]===oppT || self[colIdx]===oppT) return false;
      opp[colIdx] = oppT; self[colIdx] = tgt; return true;
    }
    self[colIdx] = tgt; return true;
  };
  for (const v of order){ if (!step(v-1)) return false; }
  return true;
}
function hasAnyValidPlan(sum){
  const cols=[1,2,3,4,5,6]; const combs=[];
  (function dfs(i,target,acc){ if (target===0){ combs.push(acc.slice()); return; } if (i>=cols.length||target<0) return; acc.push(cols[i]); dfs(i+1,target-cols[i],acc); acc.pop(); dfs(i+1,target,acc); })(0,sum,[]);
  function* perm(a){ if (a.length<=1){ yield a.slice(); return; } for(let i=0;i<a.length;i++){ const f=a[i]; const r=a.slice(0,i).concat(a.slice(i+1)); for(const p of perm(r)) yield [f,...p]; } }
  for (const combo of combs){ for (const order of perm(combo)){ if (isPlanValid(order)) return true; } }
  return false;
}

// ---- Animation Queue ----
function enqueue(colIdx, mover, push){ animQueue.push({colIdx, mover, push}); }
function runQueue(done){
  if (animQueue.length===0){ animating=false; done(); return; }
  animating=true;
  const step = animQueue.shift();
  animateStep(step.colIdx, step.mover, step.push, ()=> runQueue(done));
}
function animateStep(colIdx, mover, isPush, onDone){
  const dir = (mover===0)? +1 : -1;
  const startSelf = (mover===0)? p1[colIdx] : p2[colIdx];
  const startOpp  = (mover===0)? p2[colIdx] : p1[colIdx];
  const targetSelf = startSelf + dir;
  const targetOpp  = isPush ? (startOpp + dir) : startOpp;

  const dur = 320; const t0 = performance.now();

  function frame(now){
    const t = Math.min(1, (now-t0)/dur); const e = easeInOut(t);
    draw();
    // power highlight
    const tx = PAD + colIdx*CELL, ty = PAD + targetSelf*CELL;
    ctx.save(); ctx.beginPath(); ctx.rect(tx,ty,CELL,CELL); ctx.globalAlpha = 0.35 * e;
    ctx.fillStyle = mover===0 ? '#fde68a' : '#fecaca'; ctx.fill(); ctx.globalAlpha = 1;
    ctx.restore();
    // moving sprites
    const x = PAD + colIdx*CELL + CELL/2;
    if (isPush){
      const oy = PAD + ((startOpp) + e*dir)*CELL + CELL/2; if (mover===0) drawP2Sprite(x, oy); else drawP1Sprite(x, oy);
    }
    const sy = PAD + ((startSelf) + e*dir)*CELL + CELL/2;
    if (mover===0) drawP1Sprite(x, sy); else drawP2Sprite(x, sy);

    if (t<1){ requestAnimationFrame(frame); }
    else{
      if (mover===0){ if (isPush) p2[colIdx] = targetOpp; p1[colIdx] = targetSelf; }
      else { if (isPush) p1[colIdx] = targetOpp; p2[colIdx] = targetSelf; }
      draw();
      onDone();
    }
  }
  requestAnimationFrame(frame);
}

// ---- Move execution ----
btnMove.addEventListener('click', ()=>{
  if (winner!=null || die[turn]==null || animating) return;
  if (planSum()!==die[turn]) return;
  if (!isPlanValid(plan)) return;
  animQueue = [];
  for (const v of plan){
    const colIdx = v-1;
    const isPush = ((turn===0)? p2[colIdx] : p1[colIdx]) === ((turn===0)? p1[colIdx]+1 : p2[colIdx]-1);
    enqueue(colIdx, turn, isPush);
  }
  runQueue(()=>{
    checkWin();
    plan=[]; die[turn]=null; turn=1-turn; updateControls();
  });
});

btnReset.addEventListener('click', ()=>{
  p1 = Array(COLS).fill(1); p2 = Array(COLS).fill(3); turn=0; die=[null,null]; winner=null; plan=[]; updateControls();
});

function checkWin(){
  const p1All4 = p1.every(r=>r===3);
  const p2All5 = p2.every(r=>r===4);
  const p2All1 = p2.every(r=>r===0);
  const p2All2 = p2.every(r=>r===1);
  if (p2All5 || p1All4) winner = 0;
  if (p2All1 || p2All2) winner = 1;
}

// ---- Boot ----
function frameLoop(){ draw(); requestAnimationFrame(frameLoop); }
refreshDice(); setMeta(); updateControls(); frameLoop();
</script>
</body>
</html>
